<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客搭建经验汇总</title>
    <url>/2023/05/16/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>主要是想用markdown做笔记，并保存在网络端，便于随时查看</p>
<h2 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h2><h4 id="1-Hexo-Github-搭建平台基本步骤"><a href="#1-Hexo-Github-搭建平台基本步骤" class="headerlink" title="1.Hexo + Github 搭建平台基本步骤"></a>1.Hexo + Github 搭建平台基本步骤</h4><p>（1）Typora + PicGo + 云存储平台</p>
<p>Typora是markdown的编写平台</p>
<p>PicGo + 云存储平台是为了做图床，远程传图片（云存储平台使用的是阿里云，9元&#x2F;年）</p>
<p>两个一起看，包教包会：</p>
<p><a href="https://www.bilibili.com/read/cv16760314">https://www.bilibili.com/read/cv16760314</a></p>
<p><a href="https://blog.csdn.net/weixin_43571641/article/details/126534731">https://blog.csdn.net/weixin_43571641/article/details/126534731</a></p>
<p>（2）Hexo + Github 搭建博客网站</p>
<p>hexo本地配置 <a href="https://blog.csdn.net/wapchief/article/details/54602515">https://blog.csdn.net/wapchief/article/details/54602515</a></p>
<p>配置git <a href="https://zhuanlan.zhihu.com/p/576368060">https://zhuanlan.zhihu.com/p/576368060</a></p>
<p>hexo在github上面部署 <a href="https://www.bilibili.com/read/cv14867895">https://www.bilibili.com/read/cv14867895</a></p>
<h4 id="2-NexT主体框架美化"><a href="#2-NexT主体框架美化" class="headerlink" title="2.NexT主体框架美化"></a>2.NexT主体框架美化</h4><p>（1）添加头像 + 导航栏</p>
<p>参考这篇博文：<a href="https://blog.csdn.net/qq_34003239/article/details/100883213">https://blog.csdn.net/qq_34003239/article/details/100883213</a></p>
<p>（2）不显示全文</p>
<p>首页不显示全文，也就是要在yaml中写description：<a href="https://blog.csdn.net/qq_34243930/article/details/109052481">https://blog.csdn.net/qq_34243930/article/details/109052481</a></p>
<p>写md文件的时候，在需要截断的位置加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>（3）博客文章加密</p>
<p>前端加密：<a href="https://blog.csdn.net/qq_24754061/article/details/106569222">https://blog.csdn.net/qq_24754061/article/details/106569222</a></p>
<p>（4）博客文章顶置</p>
<p><a href="https://blog.csdn.net/qq_42777659/article/details/126516780">https://blog.csdn.net/qq_42777659/article/details/126516780</a></p>
<p><a href="https://blog.csdn.net/qq_15602635/article/details/83479980">https://blog.csdn.net/qq_15602635/article/details/83479980</a></p>
]]></content>
      <categories>
        <category>计算机网络相关</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux随手记</title>
    <url>/2023/05/23/%E9%9A%8F%E6%89%8B%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><h5 id="x2F-etc-x2F-hostname与-x2F-etc-x2F-hosts的区别"><a href="#x2F-etc-x2F-hostname与-x2F-etc-x2F-hosts的区别" class="headerlink" title="&#x2F;etc&#x2F;hostname与&#x2F;etc&#x2F;hosts的区别"></a>&#x2F;etc&#x2F;hostname与&#x2F;etc&#x2F;hosts的区别</h5><p>&#x2F;etc&#x2F;hostname中存放的是主机名</p>
<p>例如：</p>
<p>ubuntu-tmp</p>
<p>&#x2F;etc&#x2F;hosts存放的是域名与ip的对应关系，域名和主机名没有任何关系，可以给任意一个IP指定任意一个名字</p>
<p>例如：</p>
<p>127.0.0.1 localhost </p>
<p>127.0.1.1 ubuntu-base</p>
</li>
<li><p><strong>Linux账号与权限管理</strong></p>
<p><a href="https://blog.csdn.net/m0_64651064/article/details/122148092">https://blog.csdn.net/m0_64651064/article/details/122148092</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux操作系统</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Linux操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Shell指令</title>
    <url>/2023/05/21/%E5%B8%B8%E7%94%A8Shell%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="更改文件权限命令-——-chmod"><a href="#更改文件权限命令-——-chmod" class="headerlink" title="更改文件权限命令 ——  chmod"></a>更改文件权限命令 ——  <code>chmod</code></h4><p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [ugoa...][[+-=][rwxX]...][,...] filename...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">u 表示该对象的拥有者，g 表示与该对象的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该对象是个子目录或者该对象已经被设定过为可执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c : 若该对象权限确实已经更改，才显示其更改动作</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f : 若该对象权限无法被更改也不要显示错误讯息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v : 显示权限变更的详细资料</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-R : 对目前目录下的所有对象与子目录进行相同的权限变更(即以递回的方式逐个变更)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">help</span> : 显示辅助说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--version : 显示版本</span></span><br></pre></td></tr></table></figure>

<p>示范：</p>
<ol>
<li><p>将对象 file1.txt 设置为所有人均可读取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>将目前目录下的所有对象与子目录皆设为任何人可读取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a+r *</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此外，还可以使用数字表示权限，起对应关系如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">r=4，w=2，x=1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若要rwx属性则4+2+1=7；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若要rw-属性则4+2=6；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若要r-x属性则4+1=5。</span></span><br></pre></td></tr></table></figure>

<p>示范：</p>
<ol>
<li><p>将对象 file1.txt 设置为所有人均有读写和执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a=rwx file1.txt</span><br><span class="line">chmod 777 file1.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="关机、重启命令"><a href="#关机、重启命令" class="headerlink" title="关机、重启命令"></a>关机、重启命令</h4><p>关机命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -h now  # 立即关机</span><br><span class="line">shutdown -h 1    # 1分钟后关机</span><br><span class="line">shutdown         # 1分钟后关机</span><br><span class="line">shutdown -r now  # 重启</span><br></pre></td></tr></table></figure>

<p>重启命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot # 重启</span><br></pre></td></tr></table></figure>



<h4 id="创建新用户、设置密码"><a href="#创建新用户、设置密码" class="headerlink" title="创建新用户、设置密码"></a>创建新用户、设置密码</h4><p>相关命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd[option] username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">option选项</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c: 加上备注文字，备注文字保存在passwd的备注栏中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d: 指定用户的家目录（默认用户名目录为/home/用户名，root用户名家目录是/root）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-D: 变更预设值。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g: 指定用户所属组</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e: 指定账号的失效日期，日期格式为MM/DD/YY，例如06/30/12。缺省表示永久有效。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f: 指定在密码过期后多少天即关闭该账号。如果为0账号立即被停用；如果为-1则账号一直可用。默认值为-1.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-m: 自动建立用户的登入目录。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-M: 不要自动建立用户的登入目录。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-M: 不要自动建立用户的登入目录。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-u: 指定用户<span class="built_in">id</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-r: 建立系统账号。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-s: 指定用户登入后所使用的shell。默认值为/bin/bash。</span></span><br><span class="line"></span><br><span class="line">passwd [username] # 用于设置/修改用户密码</span><br><span class="line">whoami            # 用于显示当前登录到系统的用户名</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux操作系统</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Linux操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始部署Ubuntu系统</title>
    <url>/2023/05/21/%E4%BB%8E%E9%9B%B6%E9%83%A8%E7%BD%B2Ubuntu%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="参考的博客（后面删掉）"><a href="#参考的博客（后面删掉）" class="headerlink" title="参考的博客（后面删掉）"></a>参考的博客（后面删掉）</h4><p><a href="https://blog.csdn.net/toradexsh/article/details/106099076">https://blog.csdn.net/toradexsh/article/details/106099076</a></p>
<p><a href="https://blog.csdn.net/zjh1229/article/details/113035997">https://blog.csdn.net/zjh1229/article/details/113035997</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个完整的Ubuntu BSP包含uboot、Linux Kernel 和 Ubuntu rootfs 三部分</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h4 id="1-移植文件系统ubuntu-rootfs"><a href="#1-移植文件系统ubuntu-rootfs" class="headerlink" title="1. 移植文件系统ubuntu rootfs"></a>1. 移植文件系统ubuntu rootfs</h4><p>（1）下载Ubuntu-Base（文件系统）</p>
<p>本次移植下载的是Ubuntu-Base 18.04.5 LTS版本的文件系统，官方链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://cdimage.ubuntu.com/ubuntu-base/releases/18.04/release/</span><br></pre></td></tr></table></figure>

<p>（2）</p>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ol>
<li><p>执行编写好的 ch-mount.sh 文件时，报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/bash^M: 解释器错误: 没有那个文件或目录</span><br></pre></td></tr></table></figure>

<p>原因：由于部署的时候，我先在Windows上写好了sh文件，再通过xftp拷贝到Linux系统下，<strong>然而dos &#x2F; windows 和 unix &#x2F; linux 换行格式编码并不相同：</strong></p>
<p>dos &#x2F; windows：【\n\r】表示换行</p>
<p>unix &#x2F; linux：      【\n】表示换行</p>
<p>解决办法：</p>
<p>使用shell指令删除【\r】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\r$//&#x27; build.sh</span><br></pre></td></tr></table></figure>

<p>再次运行便可成功</p>
</li>
<li><p>挂载ubuntu文件系统后，执行命令<code>apt update</code>，报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遇见的报错1: 无法访问网站</span></span><br><span class="line">Err:1 http://cn.archive.ubuntu.com/ubuntu bionic InRelease Could not resolve &#x27;cn.archive.ubuntu.com&#x27;</span><br><span class="line">Err:2 http://security.ubuntu.com/ubuntu bionic-security InRelease Could not resolve &#x27;security.ubuntu.com&#x27;</span><br><span class="line">Err:3 http://cn.archive.ubuntu.com/ubuntu bionic-updates InRelease Could not resolve &#x27;cn.archive.ubuntu.com&#x27;</span><br><span class="line">Err:4 http://cn.archive.ubuntu.com/ubuntu bionic-backports InRelease Could not resolve &#x27;cn.archive.ubuntu.com&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遇到的报错2: 无法创建 /tmp/xxx 文件</span></span><br><span class="line">Get:1 http://security.debian.org/debian-security buster/updates InRelease [65.4 kB]</span><br><span class="line">Err:1 http://security.debian.org/debian-security buster/updates InRelease</span><br><span class="line">  Couldn&#x27;t create temporary file /tmp/apt.conf.IRqbCz for passing config to apt-key</span><br><span class="line">Get:2 http://deb.debian.org/debian buster InRelease [122 kB]</span><br><span class="line">Err:2 http://deb.debian.org/debian buster InRelease</span><br><span class="line">  Couldn&#x27;t create temporary file /tmp/apt.conf.Afcu25 for passing config to apt-key</span><br></pre></td></tr></table></figure>

<p>针对问题1，需要正确的配置<code>/etc/hosts</code>和<code>/etc/hostname</code>，并将本地主机的<code>/etc/resolv.conf</code>拷贝到<code>./etc/resolv.conf</code>，同时保证本地主机能够正常联网，就可以解决</p>
<p>针对问题2，需要使用<code>chmod 777 /tmp/</code>设置文件夹的权限，才可以在tmp文件中创建新的文件夹及文件，可以解决该问题</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux操作系统</category>
        <category>实践记录</category>
      </categories>
      <tags>
        <tag>Linux操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>IOCTLs函数</title>
    <url>/2023/05/17/IOCTLs/</url>
    <content><![CDATA[<h2 id="ioctl函数详解"><a href="#ioctl函数详解" class="headerlink" title="ioctl函数详解"></a>ioctl函数详解</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>ioctl 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 <code>ioctl()</code> 命令的方式实现。</p>
<p>该函数从用户空间 -&gt; 内核空间的过程</p>
<p><img src="https://markdown-img-yuusya.oss-cn-shenzhen.aliyuncs.com/picture/image-20230517151041751.png" alt="image-20230517151041751"></p>
<h4 id="2-用户空间ioctl"><a href="#2-用户空间ioctl" class="headerlink" title="2.用户空间ioctl"></a>2.用户空间ioctl</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fd</td>
<td align="center">文件描述符</td>
</tr>
<tr>
<td align="center">cmd</td>
<td align="center">交互协议，设备驱动将根据cmd执行对应操作</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">可变参数arg，依赖cmd指定长度以及类型</td>
</tr>
</tbody></table>
<p>ioctl() 函数执行成功时返回 0，失败则返回 -1 并设置全局变量 errorno 值，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EBADF: fd不是一个有效的</span><br><span class="line">EFAULT: argp引用了一个不可访问的内存区域</span><br><span class="line">EINVAL: 请求或参数无效 </span><br><span class="line">ENOTTY: fd不是一个字符设备(最常见)</span><br><span class="line">ENOTTY: 指定的请求不适用于描述符fd引用的对象类型</span><br></pre></td></tr></table></figure>

<h4 id="3-驱动程序ioctl"><a href="#3-驱动程序ioctl" class="headerlink" title="3.驱动程序ioctl"></a>3.驱动程序ioctl</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>

<p>在新版内核中,<code>unlocked_ioctl()</code>与<code>compat_ioctl()</code>取代了<code>ioctl()</code></p>
<p>在字符设备驱动开发中，一般情况下只需要实现<code>unlocked_ioctl()</code>函数即可，因为在vfs层的代码直接调用<code>unlocked_ioctl()</code>函数</p>
<h4 id="4-ioctl-用户与驱动之间的协议"><a href="#4-ioctl-用户与驱动之间的协议" class="headerlink" title="4.ioctl 用户与驱动之间的协议"></a>4.ioctl 用户与驱动之间的协议</h4><p>前文提到 ioctl 方法第二个参数 cmd 为用户与驱动的 “协议”，理论上可以为任意 int 型数据，可以为 0、1、2、3……，但是为了确保该 “协议” 的唯一性，ioctl 命令应该使用更科学严谨的方法赋值，在linux中，提供了一种 ioctl 命令的统一格式，&#x3D;&#x3D;将 32 位 int 型数据划分为四个位段&#x3D;&#x3D;，如下图所示：</p>
<p><img src="https://markdown-img-yuusya.oss-cn-shenzhen.aliyuncs.com/picture/image-20230517173924527.png" alt="image-20230517173924527"></p>
<p>在内核中，提供了宏接口来生成上述的ioctl命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/uapi/asm-generic/ioctl.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir, type, nr, size) \</span></span><br><span class="line"><span class="meta">	(((dir)  &lt;&lt; _IOC_DIRSHIFT)  | \</span></span><br><span class="line"><span class="meta">	 ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((nr)   &lt;&lt; _IOC_NRSHIFT)   | \</span></span><br><span class="line"><span class="meta">	 ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br></pre></td></tr></table></figure>

<p><strong><code>dir (direction)</code></strong></p>
<p>ioctl命令访问模式（数据传输方向），占 2 bits，可选项包括：</p>
<p><code>_IOC_NONE</code>，<code>_IOC_READ</code>，<code>_IOC_WRITE</code>，<code>_IOC_READ | _IOC_WRITE</code></p>
<p>分别指示了四种访问模式：无数据，读数据，写数据，读写数据</p>
<p><strong><code>type(device type)</code></strong></p>
<p>设备类型，占据 8 bits，可以为任意 char 型字符，例如’a’，’b’，’c’等等，其主要作用是使 ioctl 命令唯一的设备标识</p>
<p><strong><code>nr(number)</code></strong></p>
<p>命令编号&#x2F;序数，占据 8 bit，可以为任意 unsigned char 型数据，取值范围 0~255，如果定义了多个 ioctl 命令，通常从 0 开始编号递增</p>
<p><strong><code>size</code></strong></p>
<p>涉及到 ioctl 函数 第三个参数 arg ，占据 13bit 或者 14bit（体系相关，arm 架构一般为 14 位），指定了 arg 的数据类型及长度，如果在驱动的 ioctl 实现中不检查，通常可以忽略该参数</p>
<p>通常，为了方便编程，会使用宏<code>_IOC()</code>衍生的接口来直接定义ioctl命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/uapi/asm-generic/ioctl.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used to create numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type, nr)           _IOC(_IOC_NONE, (type), (nr), 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type, nr, size)    _IOC(_IOC_READ, (type), (nr), (_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type, nr, size)    _IOC(_IOC_WRITE, (type), (nr), (_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type, nr, size)   _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_IO：       定义不带参数的 ioctl 命令</span><br><span class="line">_IOW：      定义带写参数的 ioctl 命令（copy_from_user）</span><br><span class="line">_IOR：      定义带读参数的 ioctl 命令（copy_to_user）</span><br><span class="line">_IOWR：     定义带读写参数的 ioctl 命令</span><br></pre></td></tr></table></figure>

<p>同时，内核还提供了反向解析 ioctl 命令的宏接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/uapi/asm-generic/ioctl.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used to decode ioctl numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr)        (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr)       (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr)         (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr)       (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux操作系统</category>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>Linux操作系统</tag>
      </tags>
  </entry>
</search>
